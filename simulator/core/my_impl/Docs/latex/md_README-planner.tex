\subsection*{Header files}

Please include {\ttfamily \hyperlink{Planner_8hpp}{Planners/\+Planner.\+hpp}} before you derive your custome class from {\ttfamily \hyperlink{classPlanner}{Planner}}. 
\begin{DoxyCode}
1 \{C++\}
2 #include "Planners/Planner.hpp"
3 class MyPlanner : public Planner \{
4     // definition body ...
5 \}
\end{DoxyCode}


\subsection*{Construction}

You are supposed to specify the dimension of {\ttfamily state} vector and {\ttfamily input} vector in the argument list of the construction of the base class {\ttfamily \hyperlink{classPlanner}{Planner}}. For example, if we want to derive a {\ttfamily My\+Planner} class, we should write the construction as follows\+: 
\begin{DoxyCode}
1 \{C++\}
2 MyPlanner::MyPlanner(/* your argument list here */) : Planner(6, d) \{
3     // construction body ...
4 \}
\end{DoxyCode}
 since a {\ttfamily \hyperlink{classHumanCar}{Human\+Car}} has a state vector of dimension 6 (location X, location Y, yaw angle, speed X, speed Y, angular speed of yaw), and an input vector of dimension d (the {\ttfamily input} vector is the output of Zeji\textquotesingle{}s planner).

\subsection*{Overriding the virtual method}

All the interface of a {\ttfamily \hyperlink{classPlanner}{Planner}} lies in the virtual method {\ttfamily update}. The signature of this function is\+: 
\begin{DoxyCode}
1 \{C++\}
2 typedef std::vector<double> Vector;
3 Vector Planner::update(Vector currentState, const Vector &humanInput, std::vector<Agent*> agents);
\end{DoxyCode}


It takes input of the current state of the agent, the human input (if your planner needs it), and information of other agents. It will have the fourth argument {\ttfamily Environment} in future versions, but right now we do not have this parameter.

It outputs the input vector, which the simulator will pass to the agent controller and use it to update the agent state for the next iteration.

For example, for the \hyperlink{classHumanCar}{Human\+Car}, we should write our overridden implementation as\+: 
\begin{DoxyCode}
1 \{C++\}
2 Vector HumanCarPlanner::update(Vector currentState, const Vector &humanInput, std::vector<Agent*> agents) \{
3     return Vector(humanInput); // directly use the human input for the planner output
4 \}
\end{DoxyCode}


\subsection*{If you need information of other agents...}

For each agent, there is a {\ttfamily get\+State()} method, which gives the state vector of this agent. For a car, this state vector has 6 dimensions\+: location x, location y, yaw angle, speed x, speed y, angular velocity of yaw. You can use the vector {\ttfamily agents} to get information of the environment.

\subsection*{Exception handling}

If the dimensions of the vectors do not match, an {\ttfamily std\+::runtime\+\_\+error} will be thrown. For example, if we give a 5-\/dimension vector {\ttfamily state} to our {\ttfamily \hyperlink{classHumanCarPlanner}{Human\+Car\+Planner}}, which expects a 6-\/dimension state vector\+: 
\begin{DoxyCode}
1 \{C++\}
2 try \{
3     Vector currentState = Vector \{0, 0, 0, 1, 2\}; // 5-dimension state vector
4     humanCarPlanner.update(currentState, humanInput, agents); // HumanCar expects 6-dimension state vector
5 \}
6 catch (std::runtime\_error e) \{
7     std::cout << e.what() << std::endl;
8 \}
\end{DoxyCode}
 